<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, viewport-fit=cover"
    />
    <title>KnifeScoutz</title>
    <style>
      html,
      body {
        height: 100%;
        margin: 0;
        background: #111;
        color: #ddd;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu,
          Cantarell, Noto Sans, Helvetica Neue, Arial, "Apple Color Emoji",
          "Segoe UI Emoji";
      }
      #hud {
        position: fixed;
        left: 0;
        right: 0;
        top: 0;
        display: flex;
        gap: 12px;
        align-items: center;
        padding: 8px 10px;
        background: rgba(0, 0, 0, 0.4);
        backdrop-filter: blur(6px);
        z-index: 1000;
        font-size: 14px;
      }
      #hud .spacer {
        flex: 1;
      }
      #footer {
        position: fixed;
        left: 0;
        right: 0;
        bottom: 0;
        padding: 8px 10px;
        font-size: 12px;
        color: #8aa;
        opacity: 0.9;
      }
      #controls {
        position: fixed;
        right: 10px;
        top: 60px;
        background: rgba(0, 0, 0, 0.8);
        backdrop-filter: blur(8px);
        padding: 12px 16px;
        border-radius: 8px;
        border: 1px solid #333;
        min-width: 240px;
        z-index: 1000;
      }
      #controls h3 {
        margin: 0 0 12px 0;
        font-size: 14px;
        font-weight: 600;
        color: #fff;
      }
      .control-item {
        margin-bottom: 12px;
      }
      .control-item:last-child {
        margin-bottom: 0;
      }
      .control-label {
        display: flex;
        justify-content: space-between;
        margin-bottom: 4px;
        font-size: 12px;
        color: #aaa;
      }
      .control-value {
        color: #5af;
        font-weight: 500;
      }
      input[type="range"] {
        width: 100%;
        height: 4px;
        border-radius: 2px;
        background: #2a2a2a;
        outline: none;
        appearance: none;
        -webkit-appearance: none;
      }
      input[type="range"]::-webkit-slider-thumb {
        appearance: none;
        -webkit-appearance: none;
        width: 14px;
        height: 14px;
        border-radius: 50%;
        background: #2a6fd6;
        cursor: pointer;
        transition: background 0.15s;
      }
      input[type="range"]::-webkit-slider-thumb:hover {
        background: #4a8ff6;
      }
      input[type="range"]::-moz-range-thumb {
        width: 14px;
        height: 14px;
        border-radius: 50%;
        background: #2a6fd6;
        cursor: pointer;
        border: none;
        transition: background 0.15s;
      }
      input[type="range"]::-moz-range-thumb:hover {
        background: #4a8ff6;
      }
      #musicToggle {
        transition: all 0.2s ease;
        border: 1px solid #555;
        border-radius: 4px;
        padding: 6px 12px;
        font-size: 12px;
        cursor: pointer;
        background: #222;
        color: #eee;
      }
      #musicToggle:hover {
        background: #333;
        transform: scale(1.05);
      }
    </style>
    <script src="./netplayLib.js"></script>
  </head>
  <body>
    <div id="hud">
      <div>
        <strong>Controls:</strong> WASD/Arrows - Move | Up Arrow - Jump | Space
        - Dash/Fire | J - Toggle Knife/Gun Mode
      </div>
      <div style="font-weight: bold; font-size: 16px; margin-left: 20px">
        <span style="color: #ff5a5a">Knife</span
        ><span style="color: #62a5ff">Scoutz</span>
      </div>
      <div class="spacer"></div>
      <button id="musicToggle" style="margin-right: 10px">ðŸŽµ Music ON</button>
      <div id="statusText">Waiting for connection...</div>
    </div>

    <div id="controls">
      <h3>Physics Controls</h3>
      <div class="control-item">
        <div class="control-label">
          <span>ðŸ”ª/ðŸ”« Mode Toggle</span>
          <span class="control-value">Press J</span>
        </div>
        <div style="font-size: 10px; color: #888; margin-top: 4px">
          Knife: accel 1.2, speed 7<br />
          Gun: accel 0.2, speed 2.1
        </div>
      </div>
      <div class="control-item">
        <div class="control-label">
          <span>Gravity</span>
          <span class="control-value" id="gravityValue">--</span>
        </div>
        <input type="range" id="gravitySlider" min="0" max="2" step="0.1" />
      </div>
      <div class="control-item">
        <div class="control-label">
          <span>ðŸ”ª Run Acceleration</span>
          <span class="control-value" id="runAccelValue">--</span>
        </div>
        <input type="range" id="runAccelSlider" min="0" max="5" step="0.1" />
      </div>
      <div class="control-item">
        <div class="control-label">
          <span>ðŸ”ª Max Run Speed</span>
          <span class="control-value" id="maxRunSpeedValue">--</span>
        </div>
        <input
          type="range"
          id="maxRunSpeedSlider"
          min="1"
          max="15"
          step="0.1"
        />
      </div>
      <div class="control-item">
        <div class="control-label">
          <span>Jump Power</span>
          <span class="control-value" id="jumpImpulseValue">--</span>
        </div>
        <input
          type="range"
          id="jumpImpulseSlider"
          min="5"
          max="20"
          step="0.5"
        />
      </div>
      <div class="control-item">
        <div class="control-label">
          <span>ðŸ”« Bullet Speed</span>
          <span class="control-value" id="bulletSpeedValue">--</span>
        </div>
        <input
          type="range"
          id="bulletSpeedSlider"
          min="1"
          max="20"
          step="0.5"
        />
      </div>
    </div>

    <div id="footer"></div>

    <script>
      (function () {
        const DEV_SLIDERS = false;

        const { Game, RollbackWrapper, NetplayPlayer, DefaultInput, Vec2 } =
          netplayjs;

        // ===== PHYSICS PARAMETERS (centralized, modifiable via sliders) =====
        let physicsParams = {
          // Global physics
          gravity: 0.1,
          friction: 0.5,
          jumpImpulse: 4.0,
          airControlMultiplier: 1, // Air acceleration is 30% of ground acceleration
          airSpeedMultiplier: 0.6, // Air max speed is 60% of ground max speed

          // Knife mode physics
          knife: {
            runAccel: 10,
            maxRunSpeed: 6,
            dashForce: 100, // High force for extended range and near-instantaneous dash
            dashCooldown: 180, // frames (3s at 60fps)
            reach: 18,
            length: 12,
            width: 4,
            hitSize: 6,
          },

          // Gun mode physics
          gun: {
            runAccel: 0.2,
            maxRunSpeed: 2.1,
            bulletSpeed: 8.0,
            beamCooldown: 180, // frames (3s at 60fps)
            reach: 16,
          },
        };

        // Wire up physics control sliders
        function setupPhysicsControls() {
          // Gravity slider
          const gravitySlider = document.getElementById("gravitySlider");
          const gravityValue = document.getElementById("gravityValue");
          gravitySlider.value = physicsParams.gravity;
          gravityValue.textContent = physicsParams.gravity.toFixed(1);
          gravitySlider.addEventListener("input", (e) => {
            const val = parseFloat(e.target.value);
            physicsParams.gravity = val;
            gravityValue.textContent = val.toFixed(1);
          });

          // Run Acceleration (knife mode)
          const runAccelSlider = document.getElementById("runAccelSlider");
          const runAccelValue = document.getElementById("runAccelValue");
          runAccelSlider.value = physicsParams.knife.runAccel;
          runAccelValue.textContent = physicsParams.knife.runAccel.toFixed(1);
          runAccelSlider.addEventListener("input", (e) => {
            const val = parseFloat(e.target.value);
            physicsParams.knife.runAccel = val;
            runAccelValue.textContent = val.toFixed(1);
          });

          // Max Run Speed (knife mode)
          const maxRunSpeedSlider =
            document.getElementById("maxRunSpeedSlider");
          const maxRunSpeedValue = document.getElementById("maxRunSpeedValue");
          maxRunSpeedSlider.value = physicsParams.knife.maxRunSpeed;
          maxRunSpeedValue.textContent =
            physicsParams.knife.maxRunSpeed.toFixed(1);
          maxRunSpeedSlider.addEventListener("input", (e) => {
            const val = parseFloat(e.target.value);
            physicsParams.knife.maxRunSpeed = val;
            maxRunSpeedValue.textContent = val.toFixed(1);
          });

          // Jump Power slider
          const jumpImpulseSlider =
            document.getElementById("jumpImpulseSlider");
          const jumpImpulseValue = document.getElementById("jumpImpulseValue");
          jumpImpulseSlider.value = physicsParams.jumpImpulse;
          jumpImpulseValue.textContent = physicsParams.jumpImpulse.toFixed(1);
          jumpImpulseSlider.addEventListener("input", (e) => {
            const val = parseFloat(e.target.value);
            physicsParams.jumpImpulse = val;
            jumpImpulseValue.textContent = val.toFixed(1);
          });

          // Bullet Speed (gun mode)
          const bulletSpeedSlider =
            document.getElementById("bulletSpeedSlider");
          const bulletSpeedValue = document.getElementById("bulletSpeedValue");
          bulletSpeedSlider.value = physicsParams.gun.bulletSpeed;
          bulletSpeedValue.textContent =
            physicsParams.gun.bulletSpeed.toFixed(1);
          bulletSpeedSlider.addEventListener("input", (e) => {
            const val = parseFloat(e.target.value);
            physicsParams.gun.bulletSpeed = val;
            bulletSpeedValue.textContent = val.toFixed(1);
          });
        }
        setupPhysicsControls();

        // ===== MUSIC SYSTEM =====
        let audioCtx;
        let master;
        let reverb;
        let musicEnabled = true;
        let musicStarted = false;

        // Initialize music system
        function initMusic() {
          if (musicStarted) return;
          audioCtx = new (window.AudioContext || window.webkitAudioContext)();

          // Master gain
          master = audioCtx.createGain();
          master.gain.value = 0.36; // 20% louder than before
          master.connect(audioCtx.destination);

          // Reverb
          function createReverb(duration = 5, decay = 2) {
            const rate = audioCtx.sampleRate;
            const length = rate * duration;
            const impulse = audioCtx.createBuffer(2, length, rate);
            for (let c = 0; c < 2; c++) {
              const ch = impulse.getChannelData(c);
              for (let i = 0; i < length; i++) {
                ch[i] =
                  (Math.random() * 2 - 1) * Math.pow(1 - i / length, decay);
              }
            }
            const convolver = audioCtx.createConvolver();
            convolver.buffer = impulse;
            return convolver;
          }
          reverb = createReverb(6, 3);

          // Filter chain
          const lowpass = audioCtx.createBiquadFilter();
          lowpass.type = "lowpass";
          lowpass.frequency.value = 1800;

          const highpass = audioCtx.createBiquadFilter();
          highpass.type = "highpass";
          highpass.frequency.value = 120;

          reverb.connect(lowpass);
          lowpass.connect(highpass);
          highpass.connect(master);

          // Global LFOs
          const filterLFO = audioCtx.createOscillator();
          const filterGain = audioCtx.createGain();
          filterLFO.frequency.value = 0.02;
          filterGain.gain.value = 800;
          filterLFO.connect(filterGain);
          filterGain.connect(lowpass.frequency);
          filterLFO.start();

          // Scale â€” E natural minor
          window.musicScale = [
            164.81, 185.0, 196.0, 220.0, 246.94, 261.63, 293.66, 329.63,
          ];

          musicStarted = true;
        }

        // Music sound effects
        function playMetal(freq) {
          if (!musicEnabled || !audioCtx) return;

          const osc1 = audioCtx.createOscillator();
          const osc2 = audioCtx.createOscillator();
          const gain = audioCtx.createGain();
          const pan = audioCtx.createStereoPanner();

          osc1.type = "sine";
          osc2.type = "square";
          osc1.frequency.value = freq;
          osc2.frequency.value = freq * 2.01;

          gain.gain.setValueAtTime(0.15, audioCtx.currentTime);
          gain.gain.exponentialRampToValueAtTime(
            0.001,
            audioCtx.currentTime + 1.5
          );
          pan.pan.value = (Math.random() - 0.5) * 1.0;

          osc1.connect(gain);
          osc2.connect(gain);
          gain.connect(pan);
          pan.connect(reverb);

          osc1.start();
          osc2.start();
          osc1.stop(audioCtx.currentTime + 1.5);
          osc2.stop(audioCtx.currentTime + 1.5);
        }

        function playEcho(freq) {
          if (!musicEnabled || !audioCtx) return;

          for (let i = 0; i < 3; i++) {
            const delay = i * 0.25;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = "triangle";
            osc.frequency.value = freq;
            gain.gain.setValueAtTime(
              0.08 / (i + 1),
              audioCtx.currentTime + delay
            );
            gain.gain.exponentialRampToValueAtTime(
              0.001,
              audioCtx.currentTime + delay + 1
            );
            osc.connect(gain);
            gain.connect(reverb);
            osc.start(audioCtx.currentTime + delay);
            osc.stop(audioCtx.currentTime + delay + 1);
          }
        }

        function playPulse() {
          if (!musicEnabled || !audioCtx) return;

          const osc = audioCtx.createOscillator();
          const gain = audioCtx.createGain();
          osc.type = "square";
          osc.frequency.value = 82.41; // E2
          gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
          gain.gain.exponentialRampToValueAtTime(
            0.001,
            audioCtx.currentTime + 0.5
          );
          osc.connect(gain);
          gain.connect(reverb);
          osc.start();
          osc.stop(audioCtx.currentTime + 0.5);
        }

        // Music sequencing
        function musicSequence() {
          if (!musicEnabled || !audioCtx || audioCtx.state !== "running")
            return;

          const randomNote =
            window.musicScale[
              Math.floor(Math.random() * window.musicScale.length)
            ];
          if (Math.random() < 0.6) playMetal(randomNote * 2);
          if (Math.random() < 0.4) playEcho(randomNote * 0.5);
          if (Math.random() < 0.2) playPulse();

          setTimeout(musicSequence, Math.random() * 600 + 400);
        }

        // Toggle music on/off
        function toggleMusic() {
          musicEnabled = !musicEnabled;
          const button = document.getElementById("musicToggle");

          if (musicEnabled) {
            button.textContent = "ðŸŽµ Music ON";
            button.style.background = "#222";
            if (!musicStarted) {
              initMusic();
              audioCtx.resume();
              musicSequence();
            }
          } else {
            button.textContent = "ðŸ”‡ Music OFF";
            button.style.background = "#444";
          }
        }

        // Setup music toggle button
        document
          .getElementById("musicToggle")
          .addEventListener("click", toggleMusic);

        // Initialize music on first user interaction
        let musicInitialized = false;
        function initializeMusicOnInteraction() {
          if (musicInitialized) return;
          musicInitialized = true;
          initMusic();
          audioCtx.resume();
          musicSequence();
        }

        // Hide controls panel if DEV_SLIDERS is false
        if (!DEV_SLIDERS) {
          const controlsPanel = document.getElementById("controls");
          if (controlsPanel) {
            controlsPanel.style.display = "none";
          }
        }

        const TILE_SIZE = 24;

        // Level legend:
        //   # = solid border
        //   B = breakable (breaks 10s after first touch, respawns after 5s)
        //   S = spawn area (left/topmost used for both)
        //   F = finish gate
        //   * = star (gives 9 kill points and kills other player)
        const LEVEL = [
          "############################################",
          "#S                 *                       #",
          "#                BBBBB                     #",
          "#                                         #",
          "#           BBBBBBBBBBBBBBBB              #",
          "#                                         #",
          "# BBBBB                                    #",
          "#                                         #",
          "#     BBBBB                               #",
          "#                                         #",
          "#         BBBBB                            #",
          "#                                         #",
          "#                BBBBB                    #",
          "#                                         #",
          "#S                                       F#",
          "############################################",
        ];

        const LEVEL_W = LEVEL[0].length;
        const LEVEL_H = LEVEL.length;
        const CANVAS_W = LEVEL_W * TILE_SIZE; // show full level width
        const CANVAS_H = LEVEL_H * TILE_SIZE; // show full level height

        function findSpawnPositions() {
          const spawns = [];
          for (let y = 0; y < LEVEL_H; y++) {
            for (let x = 0; x < LEVEL_W; x++) {
              if (LEVEL[y][x] === "S") {
                spawns.push({
                  x: (x + 0.5) * TILE_SIZE,
                  y: (y - 0.2) * TILE_SIZE,
                });
              }
            }
          }
          if (spawns.length === 0)
            return [{ x: TILE_SIZE * 2, y: TILE_SIZE * 2 }];
          if (spawns.length === 1) spawns.push(spawns[0]);
          return spawns.slice(0, 2);
        }

        // Find a safe spawn near the bottom-right of the map interior.
        function findBottomRightSpawn() {
          // Search from bottom-right inward for empty air with solid ground beneath.
          for (let y = LEVEL_H - 2; y >= 1; y--) {
            for (let x = LEVEL_W - 2; x >= 1; x--) {
              const here = LEVEL[y][x];
              const below = LEVEL[y + 1][x];
              // Standable if current tile is empty space and below is solid or breakable.
              if (here === " " && (below === "#" || below === "B")) {
                return {
                  x: (x + 0.5) * TILE_SIZE,
                  y: (y - 0.2) * TILE_SIZE,
                };
              }
            }
          }
          // Fallback to near bottom-right if no suitable tile found.
          return {
            x: (LEVEL_W - 2.5) * TILE_SIZE,
            y: (LEVEL_H - 2.2) * TILE_SIZE,
          };
        }

        function rectsOverlap(a, b) {
          return (
            a.x < b.x + b.w &&
            a.x + a.w > b.x &&
            a.y < b.y + b.h &&
            a.y + a.h > b.y
          );
        }

        // Check if a position is legal (no collision with solid tiles)
        function isPositionLegal(game, x, y, width = 16, height = 22) {
          const xMin = Math.floor((x - width / 2) / TILE_SIZE);
          const xMax = Math.floor((x + width / 2) / TILE_SIZE);
          const yMin = Math.floor((y - height / 2) / TILE_SIZE);
          const yMax = Math.floor((y + height / 2) / TILE_SIZE);

          for (let ty = yMin; ty <= yMax; ty++) {
            for (let tx = xMin; tx <= xMax; tx++) {
              const t = game.tileAt(tx, ty);
              if (t === "#" || t === "B") {
                const tileRect = {
                  x: tx * TILE_SIZE,
                  y: ty * TILE_SIZE,
                  w: TILE_SIZE,
                  h: TILE_SIZE,
                };
                const playerRect = {
                  x: x - width / 2,
                  y: y - height / 2,
                  w: width,
                  h: height,
                };
                if (rectsOverlap(playerRect, tileRect)) {
                  return false;
                }
              }
            }
          }
          return true;
        }

        class PlatformerGame extends Game {
          static timestep = 1000 / 60;
          static canvasSize = { width: CANVAS_W, height: CANVAS_H };
          static highDPI = true;

          // Replicated state
          players = [];
          started = false;
          winnerPlayerId = undefined; // number | undefined
          breakTimers = {}; // key "x,y" -> frames remaining until break
          broken = {}; // key "x,y" -> frame number when tile broke (for respawn tracking)
          lasers = []; // active lasers { ownerId, x1, y1, x2, y2, spawnTime } (time in frames)
          frameCount = 0; // total frames elapsed since game start
          collectedStars = {}; // key "x,y" -> true if star at this position has been collected

          tileAt(tx, ty) {
            if (tx < 0 || ty < 0 || tx >= LEVEL_W || ty >= LEVEL_H) return "#";
            const key = tx + "," + ty;
            const brokeFrame = this.broken[key];
            if (brokeFrame !== undefined) {
              // Check if 5 seconds (300 frames) have passed for respawn
              const framesSinceBroken = this.frameCount - brokeFrame;
              if (framesSinceBroken < 300) {
                return " "; // Still broken
              }
              // Respawn: remove from broken list
              delete this.broken[key];
            }
            const tile = LEVEL[ty][tx];
            // If it's a star and has been collected, return empty space
            if (tile === "*" && this.collectedStars[key]) {
              return " ";
            }
            return tile;
          }
          breakTile(tx, ty) {
            const key = tx + "," + ty;
            this.broken[key] = this.frameCount;
          }

          collectStar(tx, ty, collector) {
            const key = tx + "," + ty;
            if (LEVEL[ty][tx] === "*" && !this.collectedStars[key]) {
              this.collectedStars[key] = true;
              // Give collector 9 kill points
              collector.kills += 9;
              // Play star collection sound
              if (musicEnabled && window.musicScale) {
                const starNote = window.musicScale[4]; // Use 5th note for star
                playEcho(starNote * 4); // High pitch for star collection
              }
              // Kill the other player
              for (const other of this.players) {
                if (other.id !== collector.id) {
                  this.handlePlayerDeath(other, collector);
                }
              }
              return true; // Star was collected
            }
            return false; // No star to collect
          }

          // Non-replicated transient
          nonrep = { overlayClickArmed: true };

          constructor(canvas, players) {
            super();
            const spawnPositions = findSpawnPositions();
            this.players = players.map((p, idx) => ({
              id: p.getID(),
              x: spawnPositions[idx].x,
              y: spawnPositions[idx].y,
              vx: 0,
              vy: 0,
              onGround: false,
              deaths: 0,
              kills: 0,
              mode: "knife", // "knife" or "gun"
              lastDir: 1, // 1 = right, -1 = left
              beamCooldown: 0, // frames until next beam
              dashCooldown: 0, // frames until next dash (knife mode)
              dashTrail: [], // Array of {x, y, time} for dash trail effect
              invulnerabilityTimer: 0, // frames of invulnerability remaining
            }));
            // Ensure red player (id 0) starts bottom-right.
            const br = findBottomRightSpawn();
            if (this.players[0]) {
              this.players[0].x = br.x;
              this.players[0].y = br.y;
            }
          }

          resetAll(players) {
            // Reset level breakables and player state
            this.breakTimers = {};
            this.broken = {};
            this.collectedStars = {};
            this.winnerPlayerId = undefined;
            this.started = false;
            this.lasers = [];
            this.frameCount = 0;
            const spawnPositions = findSpawnPositions();
            this.players.forEach((pl, idx) => {
              pl.x = spawnPositions[idx].x;
              pl.y = spawnPositions[idx].y;
              pl.vx = 0;
              pl.vy = 0;
              pl.onGround = false;
              pl.kills = 0;
              pl.mode = "knife";
              pl.lastDir = 1;
              pl.beamCooldown = 0;
              pl.dashCooldown = 0;
              pl.dashTrail = [];
              pl.invulnerabilityTimer = 0;
            });
            // Keep red player (id 0) bottom-right on reset.
            const br = findBottomRightSpawn();
            if (this.players[0]) {
              this.players[0].x = br.x;
              this.players[0].y = br.y;
            }
          }

          // If either player's input indicates intent to start, start.
          maybeStart(inputs) {
            if (this.started) return;
            for (const [, input] of inputs) {
              const kp = input.keysPressed || {};
              if (kp[" "] || kp["Enter"] || kp["Space"] || kp["z"] || kp["x"]) {
                this.started = true;
                // Initialize music on game start
                initializeMusicOnInteraction();
                return;
              }
              const v = input.wasd();
              if (v.x !== 0 || v.y !== 0) {
                this.started = true;
                // Initialize music on game start
                initializeMusicOnInteraction();
                return;
              }
            }
          }

          handlePlayerDeath(pl, killer) {
            pl.deaths += 1;
            if (killer) {
              killer.kills += 1;
              // Play kill sound effect
              if (musicEnabled && window.musicScale) {
                const killNote =
                  window.musicScale[
                    Math.floor(Math.random() * window.musicScale.length)
                  ];
                playMetal(killNote * 3); // Higher pitch for kills
              }
            }
            const spawnPositions = findSpawnPositions();
            if (pl.id === 0) {
              const br = findBottomRightSpawn();
              pl.x = br.x;
              pl.y = br.y;
            } else {
              const idx = 1; // blue player uses the other spawn marker
              pl.x = spawnPositions[idx].x;
              pl.y = spawnPositions[idx].y;
            }
            pl.vx = 0;
            pl.vy = 0;
            pl.onGround = false;
            pl.invulnerabilityTimer = 180; // 3 seconds at 60fps

            // Also respawn the killer
            if (killer) {
              const killerSpawnPositions = findSpawnPositions();
              if (killer.id === 0) {
                const br = findBottomRightSpawn();
                killer.x = br.x;
                killer.y = br.y;
              } else {
                const idx = 1; // blue player uses the other spawn marker
                killer.x = killerSpawnPositions[idx].x;
                killer.y = killerSpawnPositions[idx].y;
              }
              killer.vx = 0;
              killer.vy = 0;
              killer.onGround = false;
              killer.invulnerabilityTimer = 180; // 3 seconds at 60fps
            }
          }

          // Raycast from (x, y) in direction (dx, dy) until edge of map (passes through terrain)
          raycastLaser(x, y, dx, dy) {
            const maxDist = Math.max(CANVAS_W, CANVAS_H) * 2;
            const step = 1; // pixel steps for raycasting
            let currentX = x;
            let currentY = y;

            for (let dist = 0; dist < maxDist; dist += step) {
              currentX += dx * step;
              currentY += dy * step;

              // Check if we've gone off the map edges
              if (
                currentX < 0 ||
                currentX >= CANVAS_W ||
                currentY < 0 ||
                currentY >= CANVAS_H
              ) {
                return { x: currentX, y: currentY };
              }
            }

            return { x: currentX, y: currentY };
          }

          // Check if a line segment intersects with a rectangle
          lineIntersectsRect(x1, y1, x2, y2, rect) {
            // Check if either endpoint is inside the rectangle
            if (
              x1 >= rect.x &&
              x1 <= rect.x + rect.w &&
              y1 >= rect.y &&
              y1 <= rect.y + rect.h
            )
              return true;
            if (
              x2 >= rect.x &&
              x2 <= rect.x + rect.w &&
              y2 >= rect.y &&
              y2 <= rect.y + rect.h
            )
              return true;

            // Check if line intersects any of the rectangle's edges
            const lineIntersectsLine = (
              ax1,
              ay1,
              ax2,
              ay2,
              bx1,
              by1,
              bx2,
              by2
            ) => {
              const denom =
                (by2 - by1) * (ax2 - ax1) - (bx2 - bx1) * (ay2 - ay1);
              if (Math.abs(denom) < 0.0001) return false; // parallel

              const ua =
                ((bx2 - bx1) * (ay1 - by1) - (by2 - by1) * (ax1 - bx1)) / denom;
              const ub =
                ((ax2 - ax1) * (ay1 - by1) - (ay2 - ay1) * (ax1 - bx1)) / denom;

              return ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1;
            };

            // Check against all four edges
            if (
              lineIntersectsLine(
                x1,
                y1,
                x2,
                y2,
                rect.x,
                rect.y,
                rect.x + rect.w,
                rect.y
              )
            )
              return true;
            if (
              lineIntersectsLine(
                x1,
                y1,
                x2,
                y2,
                rect.x + rect.w,
                rect.y,
                rect.x + rect.w,
                rect.y + rect.h
              )
            )
              return true;
            if (
              lineIntersectsLine(
                x1,
                y1,
                x2,
                y2,
                rect.x,
                rect.y + rect.h,
                rect.x + rect.w,
                rect.y + rect.h
              )
            )
              return true;
            if (
              lineIntersectsLine(
                x1,
                y1,
                x2,
                y2,
                rect.x,
                rect.y,
                rect.x,
                rect.y + rect.h
              )
            )
              return true;

            return false;
          }

          tick(playerInputs) {
            // Game is only playable after both peers connect (wrapper guarantees), plus explicit start.
            this.maybeStart(playerInputs);
            if (!this.started) return;

            this.frameCount += 1;

            const gravity = physicsParams.gravity;
            const jumpImpulse = physicsParams.jumpImpulse;
            const friction = physicsParams.friction;

            // Advance timers for breakable tiles; when they hit 0, remove tile.
            for (const key of Object.keys(this.breakTimers)) {
              this.breakTimers[key] -= 1;
              if (this.breakTimers[key] <= 0) {
                const [tx, ty] = key.split(",").map(Number);
                if (this.tileAt(tx, ty) === "B") this.breakTile(tx, ty);
                delete this.breakTimers[key];
              }
            }

            for (const [np, input] of playerInputs) {
              const id = np.getID();
              const pl = this.players[id];
              if (!pl) continue;

              // Decrement invulnerability timer
              if (pl.invulnerabilityTimer > 0) {
                pl.invulnerabilityTimer -= 1;
              }

              // Handle mode toggle (j key)
              const pressed = input.keysPressed || {};
              if (pressed["j"]) {
                pl.mode = pl.mode === "knife" ? "gun" : "knife";
              }

              // Knife mode: handle dash ability
              if (pl.mode === "knife") {
                if (pl.dashCooldown > 0) {
                  pl.dashCooldown -= 1;
                }

                // Dash on spacebar press (if not cooling down)
                const dashPressed = !!(pressed[" "] || pressed["Space"]);
                if (dashPressed && pl.dashCooldown === 0) {
                  // Calculate maximum safe dash distance
                  const dashDirection = pl.lastDir;
                  const maxDashDistance = physicsParams.knife.dashForce;
                  let safeDashDistance = maxDashDistance;

                  // Binary search to find maximum safe distance
                  let minDistance = 0;
                  let maxDistance = maxDashDistance;
                  const searchSteps = 10; // Number of binary search steps

                  for (let step = 0; step < searchSteps; step++) {
                    const testDistance = (minDistance + maxDistance) / 2;
                    const testX = pl.x + dashDirection * testDistance;
                    const testY = pl.y;

                    if (isPositionLegal(this, testX, testY)) {
                      minDistance = testDistance;
                      safeDashDistance = testDistance;
                    } else {
                      maxDistance = testDistance;
                    }
                  }

                  // Record dash for collision resolution after all players move
                  pl.pendingDash = {
                    startX: pl.x,
                    startY: pl.y,
                    endX: pl.x + dashDirection * safeDashDistance,
                    endY: pl.y, // horizontal dash
                  };

                  // Create trail segments during dash
                  const currentTime = Date.now();
                  const segments = 8; // More trail segments for better visual effect
                  const trailDistance = safeDashDistance; // Use actual safe distance for trail

                  // Clear existing trail
                  pl.dashTrail = [];

                  // Create trail segments along the dash path
                  for (let i = 0; i < segments; i++) {
                    const progress = (i + 1) / segments; // Evenly distributed along path
                    const trailX =
                      pl.x + dashDirection * trailDistance * progress;
                    const trailY = pl.y;
                    pl.dashTrail.push({
                      x: trailX,
                      y: trailY,
                      time: currentTime,
                      alpha: 0.3, // Start much more transparent
                    });
                  }

                  // Apply dash impulse for the safe distance
                  pl.vx = dashDirection * safeDashDistance;
                  pl.dashCooldown = physicsParams.knife.dashCooldown;
                }
              }

              // Mode-specific physics parameters
              let runAccel =
                pl.mode === "knife"
                  ? physicsParams.knife.runAccel
                  : physicsParams.gun.runAccel;
              let maxRunSpeed =
                pl.mode === "knife"
                  ? physicsParams.knife.maxRunSpeed
                  : physicsParams.gun.maxRunSpeed;

              // Apply air control multipliers when not on ground
              if (!pl.onGround) {
                runAccel *= physicsParams.airControlMultiplier;
                maxRunSpeed *= physicsParams.airSpeedMultiplier;
              }

              // Horizontal input
              const move = input.wasd();
              pl.vx += move.x * runAccel;

              // Only apply speed limits if not dashing (dash bypasses speed limits)
              if (pl.dashCooldown < physicsParams.knife.dashCooldown - 3) {
                // Allow 3 frames of dash movement
                if (pl.vx > maxRunSpeed) pl.vx = maxRunSpeed;
                if (pl.vx < -maxRunSpeed) pl.vx = -maxRunSpeed;
              }

              // Track last direction of travel for knife
              if (Math.abs(pl.vx) > 0.5) {
                pl.lastDir = pl.vx > 0 ? 1 : -1;
              }

              // Jump
              const held = input.keysHeld || {};
              const jumpPressed = !!(pressed["w"] || pressed["ArrowUp"]);
              if (jumpPressed && pl.onGround) {
                pl.vy = -jumpImpulse;
                pl.onGround = false;
              }

              // Gun mode: handle laser firing
              if (pl.mode === "gun") {
                if (pl.beamCooldown > 0) {
                  pl.beamCooldown -= 1;
                }

                // Fire laser on spacebar press (if not cooling down)
                const firePressed = !!(pressed[" "] || pressed["Space"]);
                if (firePressed && pl.beamCooldown === 0) {
                  // Fire horizontally in lastDir
                  const dirX = pl.lastDir;
                  const dirY = 0;

                  // Raycast to find where laser hits terrain
                  // Offset start position away from player so laser doesn't connect to them
                  const offsetDist = physicsParams.gun.reach + 4; // slightly beyond gun reach
                  const laserStart = {
                    x: pl.x + dirX * offsetDist,
                    y: pl.y + dirY * offsetDist,
                  };
                  const laserEnd = this.raycastLaser(
                    laserStart.x,
                    laserStart.y,
                    dirX,
                    dirY
                  );

                  // Check if laser hits any player
                  for (const other of this.players) {
                    if (other.id !== pl.id && other.invulnerabilityTimer <= 0) {
                      const otherRect = {
                        x: other.x - 8,
                        y: other.y - 11,
                        w: 16,
                        h: 22,
                      };
                      if (
                        this.lineIntersectsRect(
                          laserStart.x,
                          laserStart.y,
                          laserEnd.x,
                          laserEnd.y,
                          otherRect
                        )
                      ) {
                        this.handlePlayerDeath(other, pl);
                      }
                    }
                  }

                  this.lasers.push({
                    ownerId: pl.id,
                    x1: laserStart.x,
                    y1: laserStart.y,
                    x2: laserEnd.x,
                    y2: laserEnd.y,
                    spawnTime: this.frameCount,
                  });
                  pl.beamCooldown = physicsParams.gun.beamCooldown;
                }
              }

              // Gravity
              pl.vy += gravity;

              // Integrate and collide with tiles (AABB vs grid)
              const width = 16;
              const height = 22; // player AABB

              // Horizontal step
              let newX = pl.x + pl.vx;
              const xMin = Math.floor((newX - width / 2) / TILE_SIZE);
              const xMax = Math.floor((newX + width / 2) / TILE_SIZE);
              const yMin = Math.floor((pl.y - height / 2) / TILE_SIZE);
              const yMax = Math.floor((pl.y + height / 2) / TILE_SIZE);
              let blockedX = false;
              for (let ty = yMin; ty <= yMax; ty++) {
                for (let tx = xMin; tx <= xMax; tx++) {
                  const t = this.tileAt(tx, ty);
                  if (t === "#" || t === "B") {
                    const tileRect = {
                      x: tx * TILE_SIZE,
                      y: ty * TILE_SIZE,
                      w: TILE_SIZE,
                      h: TILE_SIZE,
                    };
                    const playerRect = {
                      x: newX - width / 2,
                      y: pl.y - height / 2,
                      w: width,
                      h: height,
                    };
                    if (rectsOverlap(playerRect, tileRect)) {
                      blockedX = true;
                    }
                  }
                }
              }
              if (blockedX) {
                newX = pl.x;
                pl.vx = 0;
              } else {
                pl.x = newX;
              }

              // Vertical step
              let newY = pl.y + pl.vy;
              const v_xMin = Math.floor((pl.x - width / 2) / TILE_SIZE);
              const v_xMax = Math.floor((pl.x + width / 2) / TILE_SIZE);
              const v_yMin = Math.floor((newY - height / 2) / TILE_SIZE);
              const v_yMax = Math.floor((newY + height / 2) / TILE_SIZE);
              let blockedY = false;
              let landed = false;
              for (let ty = v_yMin; ty <= v_yMax; ty++) {
                for (let tx = v_xMin; tx <= v_xMax; tx++) {
                  const t = this.tileAt(tx, ty);
                  if (t === "#" || t === "B") {
                    const tileRect = {
                      x: tx * TILE_SIZE,
                      y: ty * TILE_SIZE,
                      w: TILE_SIZE,
                      h: TILE_SIZE,
                    };
                    const playerRect = {
                      x: pl.x - width / 2,
                      y: newY - height / 2,
                      w: width,
                      h: height,
                    };
                    if (rectsOverlap(playerRect, tileRect)) {
                      blockedY = true;
                      if (
                        pl.vy > 0 &&
                        Math.abs(ty * TILE_SIZE - (pl.y + height / 2)) <
                          TILE_SIZE
                      )
                        landed = true;
                      // Start break timer if touching a breakable
                      if (t === "B") {
                        const key = tx + "," + ty;
                        if (this.breakTimers[key] == null)
                          this.breakTimers[key] = Math.round(10 * 60); // 10s @60fps
                      }
                    }
                  }
                }
              }
              if (blockedY) {
                if (pl.vy > 0 && landed) pl.onGround = true;
                else pl.onGround = false;
                pl.vy = 0;
                newY = pl.y;
              } else {
                pl.onGround = false;
                pl.y = newY;
              }

              // Finish detection
              const playerRectFull = {
                x: pl.x - width / 2,
                y: pl.y - height / 2,
                w: width,
                h: height,
              };
              const tx0 = Math.floor(playerRectFull.x / TILE_SIZE);
              const ty0 = Math.floor(playerRectFull.y / TILE_SIZE);
              const tx1 = Math.floor(
                (playerRectFull.x + playerRectFull.w) / TILE_SIZE
              );
              const ty1 = Math.floor(
                (playerRectFull.y + playerRectFull.h) / TILE_SIZE
              );
              for (let ty = ty0; ty <= ty1; ty++) {
                for (let tx = tx0; tx <= tx1; tx++) {
                  const t = this.tileAt(tx, ty);
                  if (t === "F") {
                    const tileRect = {
                      x: tx * TILE_SIZE,
                      y: ty * TILE_SIZE,
                      w: TILE_SIZE,
                      h: TILE_SIZE,
                    };
                    if (
                      rectsOverlap(playerRectFull, tileRect) &&
                      this.winnerPlayerId == null
                    ) {
                      this.winnerPlayerId = pl.id;
                      this.started = false;
                    }
                  } else if (t === "*") {
                    // Star collection detection
                    const tileRect = {
                      x: tx * TILE_SIZE,
                      y: ty * TILE_SIZE,
                      w: TILE_SIZE,
                      h: TILE_SIZE,
                    };
                    if (rectsOverlap(playerRectFull, tileRect)) {
                      this.collectStar(tx, ty, pl);
                    }
                  }
                }
              }

              // Friction if on ground and no input
              if (Math.abs(move.x) < 0.01 && pl.onGround) pl.vx *= friction;
            }

            // --- Resolve knife dashes after all players moved this tick ---
            const PLAYER_W = 16,
              PLAYER_H = 22;

            // Expand-rect helper for Minkowski sum: expand target by half the width/height of the dashing player.
            // This lets us do "segment vs expanded-rect" instead of "swept AABB vs rect".
            function expandedRectFor(other) {
              const GRACE = 2; // pixels - grace window for high-latency rollback
              return {
                x: other.x - (PLAYER_W + GRACE),
                y: other.y - (PLAYER_H + GRACE),
                w: (PLAYER_W + GRACE) * 2,
                h: (PLAYER_H + GRACE) * 2,
              };
            }

            // Segment vs axis-aligned rectangle (Liangâ€“Barsky style; returns true if intersects)
            function segmentIntersectsRect(x1, y1, x2, y2, r) {
              let t0 = 0,
                t1 = 1;
              const dx = x2 - x1,
                dy = y2 - y1;

              const clip = (p, q) => {
                if (p === 0) return q >= 0;
                const t = q / p;
                if (p < 0) {
                  if (t > t1) return false;
                  if (t > t0) t0 = t;
                } else {
                  if (t < t0) return false;
                  if (t < t1) t1 = t;
                }
                return true;
              };

              // Left, Right, Bottom, Top edges
              if (!clip(-dx, x1 - r.x)) return false;
              if (!clip(dx, r.x + r.w - x1)) return false;
              if (!clip(-dy, y1 - r.y)) return false;
              if (!clip(dy, r.y + r.h - y1)) return false;

              return t0 <= t1;
            }

            // collect and clear to avoid re-hitting next frame
            const dashes = [];
            for (const pl of this.players) {
              if (pl.pendingDash) {
                dashes.push({ owner: pl, ...pl.pendingDash });
                pl.pendingDash = undefined;
              }
            }

            // now test recorded dash segments against others' FINAL positions
            for (const dash of dashes) {
              for (const other of this.players) {
                if (other.id === dash.owner.id) continue;
                if (other.invulnerabilityTimer > 0) continue;

                const rect = expandedRectFor(other);
                if (
                  segmentIntersectsRect(
                    dash.startX,
                    dash.startY,
                    dash.endX,
                    dash.endY,
                    rect
                  )
                ) {
                  this.handlePlayerDeath(other, dash.owner);
                }
              }
            }

            // Knife mode: check knife collision with other players
            const knifeTips = []; // Store knife tip positions for knife-vs-knife collision

            for (const pl of this.players) {
              if (pl.mode === "knife") {
                const knifeReach = physicsParams.knife.reach;
                const knifeLength = physicsParams.knife.length;
                const knifeHitSize = physicsParams.knife.hitSize;

                // Calculate knife position based on velocity direction
                let angle;
                const speed = Math.sqrt(pl.vx * pl.vx + pl.vy * pl.vy);
                if (speed > 0.5) {
                  angle = Math.atan2(pl.vy, pl.vx);
                } else {
                  angle = pl.lastDir > 0 ? 0 : Math.PI;
                }

                // Hitbox at the tip of the knife
                const knifeTipDistance = knifeReach + knifeLength;
                const knifeTipX = pl.x + Math.cos(angle) * knifeTipDistance;
                const knifeTipY = pl.y + Math.sin(angle) * knifeTipDistance;

                knifeTips.push({
                  player: pl,
                  x: knifeTipX,
                  y: knifeTipY,
                  angle: angle,
                  dirX: Math.cos(angle),
                  dirY: Math.sin(angle),
                  hitSize: knifeHitSize,
                  knifeRect: {
                    x: knifeTipX - knifeHitSize / 2,
                    y: knifeTipY - knifeHitSize / 2,
                    w: knifeHitSize,
                    h: knifeHitSize,
                  },
                });
              }
            }

            // Check knife-on-knife collision: clash or kill
            let knifeClashHappened = false;
            if (knifeTips.length === 2) {
              const tip1 = knifeTips[0];
              const tip2 = knifeTips[1];
              const dist = Math.sqrt(
                (tip1.x - tip2.x) ** 2 + (tip1.y - tip2.y) ** 2
              );

              if (dist < (tip1.hitSize + tip2.hitSize) / 2) {
                // Check if knives are facing towards each other
                const dx = tip2.player.x - tip1.player.x;
                const dy = tip2.player.y - tip1.player.y;
                const playerDist = Math.sqrt(dx * dx + dy * dy);

                if (playerDist > 0) {
                  const nx = dx / playerDist;
                  const ny = dy / playerDist;

                  // Dot product of knife1 direction with vector to player2
                  const dot1 = tip1.dirX * nx + tip1.dirY * ny;
                  // Dot product of knife2 direction with vector to player1
                  const dot2 = tip2.dirX * -nx + tip2.dirY * -ny;

                  // Both dot products should be positive (knives pointing towards each other)
                  if (dot1 > 0.3 && dot2 > 0.3) {
                    // Knives are facing each other - propel players apart
                    const repelForce = 15;

                    tip1.player.vx -= nx * repelForce;
                    tip1.player.vy -= ny * repelForce;
                    tip2.player.vx += nx * repelForce;
                    tip2.player.vy += ny * repelForce;
                    knifeClashHappened = true;
                  }
                }
              }
            }

            // Check knife hits on player bodies (if no clash happened)
            if (!knifeClashHappened) {
              for (const tipData of knifeTips) {
                for (const other of this.players) {
                  if (
                    other.id !== tipData.player.id &&
                    other.invulnerabilityTimer <= 0
                  ) {
                    const otherRect = {
                      x: other.x - 8,
                      y: other.y - 11,
                      w: 16,
                      h: 22,
                    };
                    if (rectsOverlap(tipData.knifeRect, otherRect)) {
                      this.handlePlayerDeath(other, tipData.player);
                    }
                  }
                }
              }
            }

            // Remove expired lasers (after full fade: 0.1s + 3s = 3.1s = 186 frames at 60fps)
            for (let i = this.lasers.length - 1; i >= 0; i--) {
              const laser = this.lasers[i];
              const age = this.frameCount - laser.spawnTime;
              if (age > 186) {
                // 3.1 seconds
                this.lasers.splice(i, 1);
              }
            }
          }

          draw(canvas) {
            const ctx = canvas.getContext("2d");
            ctx.imageSmoothingEnabled = false;
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Background
            ctx.fillStyle = "#0e1115";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Grid
            for (let y = 0; y < LEVEL_H; y++) {
              for (let x = 0; x < LEVEL_W; x++) {
                const t = this.tileAt(x, y);
                const px = x * TILE_SIZE;
                const py = y * TILE_SIZE;

                // Draw respawning platforms with ghosted preview
                const key = x + "," + y;
                const brokeFrame = this.broken[key];
                if (brokeFrame !== undefined && LEVEL[y][x] === "B") {
                  const framesSinceBroken = this.frameCount - brokeFrame;
                  const respawnProgress = framesSinceBroken / 300; // 0 to 1

                  if (respawnProgress > 0.7) {
                    // Show ghosted preview in last 1.5 seconds
                    const alpha = (respawnProgress - 0.7) / 0.3; // 0 to 1 over last 30%
                    ctx.globalAlpha = alpha * 0.4;
                    ctx.fillStyle = "#6a7a8f";
                    ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
                    ctx.fillStyle = "#8899b0";
                    ctx.fillRect(px + 4, py + 4, TILE_SIZE - 8, TILE_SIZE - 8);
                    ctx.globalAlpha = 1;
                  }
                }

                if (t === " ") continue;
                if (t === "#") {
                  ctx.fillStyle = "#3b4450";
                  ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
                } else if (t === "B") {
                  ctx.fillStyle = "#6a7a8f";
                  ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
                  ctx.fillStyle = "#8899b0";
                  ctx.fillRect(px + 4, py + 4, TILE_SIZE - 8, TILE_SIZE - 8);
                } else if (t === "F") {
                  ctx.fillStyle = "#1e8fff";
                  ctx.fillRect(px + 8, py, 6, TILE_SIZE);
                  ctx.fillStyle = "#8ecbff";
                  ctx.fillRect(px + 2, py, 4, TILE_SIZE);
                } else if (t === "S") {
                  ctx.fillStyle = "#2b9f5a";
                  ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
                } else if (t === "*") {
                  // Draw star with golden color and glow effect
                  const centerX = px + TILE_SIZE / 2;
                  const centerY = py + TILE_SIZE / 2;
                  const starSize = 8;

                  // Glow effect
                  ctx.shadowColor = "#ffdd00";
                  ctx.shadowBlur = 8;

                  // Draw star shape
                  ctx.fillStyle = "#ffdd00";
                  ctx.beginPath();
                  for (let i = 0; i < 5; i++) {
                    const angle = (i * 4 * Math.PI) / 5;
                    const x = centerX + Math.cos(angle) * starSize;
                    const y = centerY + Math.sin(angle) * starSize;
                    if (i === 0) {
                      ctx.moveTo(x, y);
                    } else {
                      ctx.lineTo(x, y);
                    }
                  }
                  ctx.closePath();
                  ctx.fill();

                  // Reset shadow
                  ctx.shadowBlur = 0;
                }
              }
            }

            // Render dash trails
            for (const pl of this.players) {
              if (pl.dashTrail && pl.dashTrail.length > 0) {
                const currentTime = Date.now();
                const fadeDuration = 1000; // 1 second

                for (const trail of pl.dashTrail) {
                  const age = currentTime - trail.time;
                  if (age < fadeDuration) {
                    const alpha = trail.alpha * (1.0 - age / fadeDuration);
                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = pl.id === 0 ? "#ff5a5a" : "#62a5ff";
                    ctx.fillRect(trail.x - 8, trail.y - 11, 16, 22);
                    // Face/eye accents for trail
                    ctx.fillStyle = "#111";
                    ctx.fillRect(trail.x - 4, trail.y - 5, 3, 3);
                    ctx.fillRect(trail.x + 1, trail.y - 5, 3, 3);
                  }
                }
                ctx.globalAlpha = 1.0; // Reset alpha
              }
            }

            // Clean up expired trail segments
            for (const pl of this.players) {
              if (pl.dashTrail && pl.dashTrail.length > 0) {
                const currentTime = Date.now();
                const fadeDuration = 1000; // 1 second
                pl.dashTrail = pl.dashTrail.filter((trail) => {
                  const age = currentTime - trail.time;
                  return age < fadeDuration;
                });
              }
            }

            // Players
            for (const pl of this.players) {
              ctx.fillStyle = pl.id === 0 ? "#ff5a5a" : "#62a5ff";
              ctx.fillRect(pl.x - 8, pl.y - 11, 16, 22);
              // Face/eye accents
              ctx.fillStyle = "#111";
              ctx.fillRect(pl.x - 4, pl.y - 5, 3, 3);
              ctx.fillRect(pl.x + 1, pl.y - 5, 3, 3);

              // Draw knife in knife mode
              if (pl.mode === "knife") {
                const knifeReach = physicsParams.knife.reach;
                const knifeLength = physicsParams.knife.length;
                const knifeWidth = physicsParams.knife.width;

                // Calculate angle from velocity, defaulting to lastDir if stationary
                let angle;
                const speed = Math.sqrt(pl.vx * pl.vx + pl.vy * pl.vy);
                if (speed > 0.5) {
                  angle = Math.atan2(pl.vy, pl.vx);
                } else {
                  // Stationary - point in lastDir horizontally
                  angle = pl.lastDir > 0 ? 0 : Math.PI;
                }

                // Position knife at the base near player
                const knifeX = pl.x + Math.cos(angle) * knifeReach;
                const knifeY = pl.y + Math.sin(angle) * knifeReach;

                ctx.save();
                ctx.translate(knifeX, knifeY);
                ctx.rotate(angle);

                // Knife blade - triangle pointing outward
                ctx.fillStyle = "#ddd";
                ctx.beginPath();
                ctx.moveTo(0, -knifeWidth);
                ctx.lineTo(0, knifeWidth);
                ctx.lineTo(knifeLength, 0);
                ctx.closePath();
                ctx.fill();

                ctx.restore();
              }

              // Draw gun indicator in gun mode
              if (pl.mode === "gun") {
                const gunReach = physicsParams.gun.reach;
                const gunX = pl.x + pl.lastDir * gunReach;
                const gunY = pl.y;

                // Gun barrel
                ctx.fillStyle = "#555";
                ctx.fillRect(
                  pl.lastDir > 0 ? pl.x + 8 : pl.x - 8 - 8,
                  gunY - 2,
                  8,
                  4
                );

                // Gun muzzle indicator (orange tip)
                ctx.fillStyle = "#ff6600";
                ctx.fillRect(gunX - 2, gunY - 2, 4, 4);
              }

              // Mode indicator
              ctx.fillStyle = "#fff";
              ctx.font = "8px monospace";
              ctx.fillText(
                pl.mode === "knife" ? "K" : "G",
                pl.x - 3,
                pl.y - 16
              );

              // Gun reloading indicator
              if (pl.mode === "gun" && pl.beamCooldown > 0) {
                ctx.fillStyle = "#ff3333";
                ctx.font = "bold 9px monospace";
                ctx.textAlign = "center";
                ctx.fillText("reloading...", pl.x, pl.y - 24);
                ctx.textAlign = "left"; // Reset
              }

              // Knife dash reloading indicator
              if (pl.mode === "knife" && pl.dashCooldown > 0) {
                ctx.fillStyle = "#ff3333";
                ctx.font = "bold 9px monospace";
                ctx.textAlign = "center";
                ctx.fillText("reloading...", pl.x, pl.y - 24);
                ctx.textAlign = "left"; // Reset
              }

              // Invulnerability indicator
              if (pl.invulnerabilityTimer > 0) {
                ctx.fillStyle = "#00ff00";
                ctx.font = "bold 10px monospace";
                ctx.textAlign = "center";
                ctx.fillText("INVULNERABLE", pl.x, pl.y - 36);
                ctx.textAlign = "left"; // Reset
              }
            }

            // Draw lasers with fading effect (flash then trace)
            for (const laser of this.lasers) {
              const age = this.frameCount - laser.spawnTime;
              const fadeToWhiteFrames = 6; // 0.1s flash at 60fps
              const fadeOutFrames = 180; // 3s trace fade at 60fps

              let color;
              let alpha = 1;
              let lineWidth = 1.5;

              if (age < fadeToWhiteFrames) {
                // Red flash phase: interpolate from red to white
                const t = age / fadeToWhiteFrames;
                const r = 255;
                const g = Math.floor(0 + (255 - 0) * t);
                const b = Math.floor(0 + (255 - 0) * t);
                color = `rgb(${r}, ${g}, ${b})`;
                lineWidth = 2; // Slightly thicker during flash
              } else {
                // White trace phase: fade out
                const fadeAge = age - fadeToWhiteFrames;
                alpha = 1 - fadeAge / fadeOutFrames;
                if (alpha < 0) alpha = 0;
                color = `rgba(255, 255, 255, ${alpha})`;
                lineWidth = 1; // Thinner trace
              }

              ctx.strokeStyle = color;
              ctx.lineWidth = lineWidth;
              ctx.shadowColor = color;
              ctx.shadowBlur = age < fadeToWhiteFrames ? 10 : 4; // Brighter glow during flash
              ctx.beginPath();
              ctx.moveTo(laser.x1, laser.y1);
              ctx.lineTo(laser.x2, laser.y2);
              ctx.stroke();
              ctx.shadowBlur = 0;
            }

            // Kill counter at top center
            if (this.started && this.players.length === 2) {
              const p1 = this.players[0];
              const p2 = this.players[1];

              ctx.fillStyle = "rgba(0,0,0,0.6)";
              ctx.fillRect(canvas.width / 2 - 100, 5, 200, 35);

              ctx.font =
                "bold 20px system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica Neue, Arial";

              // Player 1 (red) kills
              ctx.fillStyle = "#ff5a5a";
              ctx.fillText(p1.kills.toString(), canvas.width / 2 - 60, 30);

              // Separator
              ctx.fillStyle = "#fff";
              ctx.fillText("-", canvas.width / 2 - 8, 30);

              // Player 2 (blue) kills
              ctx.fillStyle = "#62a5ff";
              ctx.fillText(p2.kills.toString(), canvas.width / 2 + 40, 30);
            }

            // Winner banner
            if (this.winnerPlayerId != null) {
              ctx.fillStyle = "rgba(0,0,0,0.5)";
              ctx.fillRect(0, 0, canvas.width, 40);
              ctx.fillStyle = "#fff";
              ctx.font =
                "bold 18px system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica Neue, Arial";
              ctx.fillText(
                "Winner: Player " +
                  (this.winnerPlayerId + 1) +
                  "  â€”  Press Space to restart",
                14,
                26
              );
            }
          }
        }

        // Allow resetting after a match using Space.
        // This is detected via keysPressed in tick; we simply re-arm started when a keypress happens after winner.
        // On any new start intent, we also reset the level breakables.
        const originalMaybeStart = PlatformerGame.prototype.maybeStart;
        PlatformerGame.prototype.maybeStart = function (inputs) {
          const beforeStarted = this.started;
          originalMaybeStart.call(this, inputs);
          if (!beforeStarted && this.started) {
            // Clear winner between rounds
            this.winnerPlayerId = undefined;
            // Reset breakables at the start of a round
            this.breakTimers = {};
            this.broken = {};
            this.collectedStars = {};
            // Reset lasers and frame count
            this.lasers = [];
            this.frameCount = 0;
          }
        };

        // Start the wrapper
        PlatformerGame.pointerLock = false;
        PlatformerGame.preventContextMenu = true;
        PlatformerGame.touchControls = {};

        const wrapper = new RollbackWrapper(PlatformerGame);
        wrapper.start();

        // Status text updates
        const statusEl = document.getElementById("statusText");

        // We poll a bit because the Game instance is encapsulated inside wrapper.
        function refreshOverlay() {
          try {
            const g = wrapper.game; // available post-start
            if (g) {
              if (g.winnerPlayerId != null)
                statusEl.textContent =
                  "Match finished â€” winner: Player " +
                  (g.winnerPlayerId + 1) +
                  ". Press Space to play again.";
              else
                statusEl.textContent = g.started
                  ? "In game"
                  : "Connected â€” press Space/Enter to start";
            }
          } catch (_) {}
          requestAnimationFrame(refreshOverlay);
        }
        refreshOverlay();

        // Overlay removed; status text keeps updating while the game runs.

        // Best-effort reset if a player leaves: when the matchmaking UI returns, the wrapper will create a new Game.
        // We observe DOM for the menu state to update status text. This is heuristic but harmless.
        const observer = new MutationObserver(() => {
          const menu = Array.from(document.querySelectorAll("div")).find((d) =>
            /Private Match|Public Match|Connection Closed/i.test(
              d.textContent || ""
            )
          );
          if (menu && /Connection Closed/i.test(menu.textContent || "")) {
            // Hard reset to return to matchmaking cleanly.
            location.reload();
          }
        });
        observer.observe(document.body, {
          subtree: true,
          childList: true,
          characterData: true,
        });
      })();
    </script>
  </body>
</html>
